const db = require("../config/db"); // Assuming your database connection is defined here

/**
 * Helper function to execute a database query and return only the rows.
 */
const query = async (sql, values) => {
	// Assuming db.query returns a tuple [rows, fields]
	const [rows] = await db.query(sql, values);
	return rows;
};

/**
 * Handles JSON serialization/deserialization for database transfer.
 */
const JSON_HELPER = {
	// Converts JS object/array to JSON string for INSERT/UPDATE
	serialize: (data) => (data ? JSON.stringify(data) : null),
	// Converts JSON string from DB to JS object/array for FETCH
	deserialize: (data) => {
		if (!data) return null;
		try {
			// MySQL returns JSON columns as string if using mysql2
			return typeof data === "string" ? JSON.parse(data) : data;
		} catch (e) {
			console.error("Error parsing JSON data from appointments table:", e);
			return null;
		}
	},
};

const AppointmentsModel = {
	/**
	 * Fetches all appointments/visits for a specific user, joining with physician data.
	 * @param {string} userId - The ID of the user.
	 * @returns {Promise<Array<object>>} A list of all patient encounters.
	 */
	findUserAppointments: async (userId) => {
		const sql = `
            SELECT
                a.*,
                p.first_name AS physician_first_name,
                p.last_name AS physician_last_name
            FROM
                appointments a
            JOIN
                physicians p ON a.physician_id = p.id
            WHERE
                a.user_id = ?
            ORDER BY
                a.appointment_date DESC, a.appointment_time DESC;
        `;

		const rows = await query(sql, [userId]);

		// Process the rows to deserialize the JSON data
		return rows.map((row) => ({
			...row,
			questionnaire_answers: JSON_HELPER.deserialize(row.questionnaire_answers),
			// The frontend can now easily filter these based on the 'status' column.
		}));
	},

	/**
	 * Saves a new appointment or updates an existing one (for rescheduling) using UPSERT logic.
	 * * NOTE: The 'id' MUST be a unique UUID generated by the service layer.
	 * * @param {object} appointmentData - The complete appointment data payload, including a mandatory UUID 'id'.
	 * @returns {Promise<string>} The UUID of the inserted/updated appointment.
	 */
	saveAppointment: async (appointmentData) => {
		const {
			id,
			user_id,
			physician_id,
			appointment_type,
			reason_for_visit,
			appointment_date,
			appointment_time,
			location_name,
			location_address,
			status,
			cancellation_reason,
			reschedule_details,
			notes,
			imaging_type,
			imaging_body_part,
			has_referral,
			referral_physician_id,
			questionnaire_answers,
		} = appointmentData;

		// CRITICAL CHECK: Ensure the UUID is provided.
		if (!id) {
			throw new Error(
				"Appointment ID (UUID) is mandatory for saving/updating an appointment."
			);
		}

		// Serialize questionnaire answers array into a JSON string for MySQL
		const answersJson = JSON_HELPER.serialize(questionnaire_answers);

		const sql = `
            INSERT INTO appointments (
                id, user_id, physician_id, appointment_type, reason_for_visit,
                appointment_date, appointment_time, location_name, location_address,
                status, cancellation_reason, reschedule_details, notes, imaging_type,
                imaging_body_part, has_referral, referral_physician_id, questionnaire_answers
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ON DUPLICATE KEY UPDATE
                physician_id = VALUES(physician_id),
                appointment_type = VALUES(appointment_type),
                reason_for_visit = VALUES(reason_for_visit),
                appointment_date = VALUES(appointment_date),
                appointment_time = VALUES(appointment_time),
                location_name = VALUES(location_name),
                location_address = VALUES(location_address),
                status = VALUES(status),
                cancellation_reason = VALUES(cancellation_reason),
                reschedule_details = VALUES(reschedule_details),
                notes = VALUES(notes),
                imaging_type = VALUES(imaging_type),
                imaging_body_part = VALUES(imaging_body_part),
                has_referral = VALUES(has_referral),
                referral_physician_id = VALUES(referral_physician_id),
                questionnaire_answers = VALUES(questionnaire_answers);
        `;

		const values = [
			id,
			user_id,
			physician_id,
			appointment_type,
			reason_for_visit,
			appointment_date,
			appointment_time,
			location_name,
			location_address,
			status,
			cancellation_reason,
			reschedule_details,
			notes,
			imaging_type,
			imaging_body_part,
			has_referral,
			referral_physician_id,
			answersJson,
		];

		try {
			await query(sql, values);
			return id;
		} catch (error) {
			console.error("Database error in saveAppointment:", error);
			throw new Error("Failed to save appointment to database.");
		}
	},
};

module.exports = AppointmentsModel;
